// Copyright 2025 Irreducible Inc.
// Copyright 2026 The Binius Developers

//! Spartan-based proof verification for Binius64 constraint systems.
//!
//! This crate provides the [`Verifier`] struct for verifying zero-knowledge proofs
//! generated by `binius_spartan_prover`. It implements the Spartan protocol adapted
//! for Binius64's constraint system.
//!
//! # When to use this crate
//!
//! Use this crate when you have a constraint system built with `binius_spartan_frontend`
//! and need to verify a Spartan-based proof. This is an alternative to the main
//! `binius_verifier` crate.
//!
//! # Key types
//!
//! - [`Verifier`] - Main verification interface; call [`Verifier::setup`] with a constraint system,
//!   then [`Verifier::verify`] with a proof and public inputs
//! - [`Error`] - Error type returned when proof verification fails
//!
//! # Related crates
//!
//! - `binius_spartan_prover` - Proving counterpart
//! - `binius_spartan_frontend` - Constraint system builder for Spartan
//! - `binius_verifier` - Alternative verification backend

#![warn(rustdoc::missing_crate_level_docs)]

pub mod config;
pub mod pcs;
pub mod wiring;

use binius_field::{BinaryField, field::FieldOps};
use binius_iop::{
	basefold_compiler::BaseFoldVerifierCompiler,
	channel::{IOPVerifierChannel, OracleLinearRelation, OracleSpec},
};
use binius_ip::channel::IPVerifierChannel;
use binius_math::{
	BinarySubspace,
	multilinear::evaluate::evaluate_inplace_scalars,
	ntt::{NeighborsLastSingleThread, domain_context::GenericOnTheFly},
};
use binius_spartan_frontend::constraint_system::{
	BlindingInfo, ConstraintSystem, ConstraintSystemPadded,
};
use binius_transcript::{VerifierTranscript, fiat_shamir::Challenger};
use binius_utils::{DeserializeBytes, checked_arithmetics::checked_log_2};
use binius_verifier::{
	fri::{self, MinProofSizeStrategy, calculate_n_test_queries},
	hash::PseudoCompressionFunction,
	merkle_tree::BinaryMerkleTreeScheme,
	protocols::{basefold, mlecheck, mlecheck::mask_buffer_dimensions, sumcheck},
};
use digest::{Digest, Output, core_api::BlockSizeUser};

pub const SECURITY_BITS: usize = 96;

/// Output of the multiplication constraint check verification.
#[derive(Debug, Clone)]
pub struct MulcheckOutput<F> {
	/// Evaluation of operand A at the challenge point.
	pub a_eval: F,
	/// Evaluation of operand B at the challenge point.
	pub b_eval: F,
	/// Evaluation of operand C at the challenge point.
	pub c_eval: F,
	/// Evaluation of the mask polynomial at the challenge point.
	pub mask_eval: F,
	/// The challenge point from the sumcheck reduction.
	pub r_x: Vec<F>,
}

/// Struct for verifying instances of a particular constraint system.
///
/// The [`Self::setup`] constructor determines public parameters for proving instances of the given
/// constraint system. Then [`Self::verify`] is called one or more times with individual instances.
#[derive(Debug, Clone)]
pub struct Verifier<F, MerkleHash, MerkleCompress>
where
	F: BinaryField,
	MerkleHash: Digest + BlockSizeUser,
	MerkleCompress: PseudoCompressionFunction<Output<MerkleHash>, 2>,
{
	constraint_system: ConstraintSystemPadded,
	/// Mask buffer dimensions (m_n, m_d) for the ZK mulcheck mask polynomial.
	mask_dims: (usize, usize),
	/// BaseFold compiler for creating verifier channels.
	basefold_compiler:
		BaseFoldVerifierCompiler<F, BinaryMerkleTreeScheme<F, MerkleHash, MerkleCompress>>,
}

impl<F, MerkleHash, MerkleCompress> Verifier<F, MerkleHash, MerkleCompress>
where
	F: BinaryField,
	MerkleHash: Digest + BlockSizeUser,
	MerkleCompress: PseudoCompressionFunction<Output<MerkleHash>, 2>,
	Output<MerkleHash>: DeserializeBytes,
{
	/// Constructs a verifier for a constraint system.
	///
	/// See [`Verifier`] struct documentation for details.
	pub fn setup(
		constraint_system: ConstraintSystem,
		log_inv_rate: usize,
		compression: MerkleCompress,
	) -> Result<Self, Error> {
		// Modify the constraint system for zero-knowledge.
		let n_fri_queries = fri::calculate_n_test_queries(SECURITY_BITS, log_inv_rate);
		let blinding_info = BlindingInfo {
			n_dummy_wires: n_fri_queries,
			// TODO: Document why these are necessary
			n_dummy_constraints: 2,
		};
		let constraint_system = ConstraintSystemPadded::new(constraint_system, blinding_info);

		// The message contains the witness and a random mask of equal size to the witness.
		// For ZK mode, the batch size is 1 (witness and mask are the two interleaved elements).
		let log_witness_size = constraint_system.log_size() as usize;
		let log_batch_size = 1;
		let log_dim = log_witness_size; // RS code dimension equals witness size
		let log_code_len = log_dim + log_inv_rate;
		let merkle_scheme = BinaryMerkleTreeScheme::new(compression);

		let n_test_queries = calculate_n_test_queries(SECURITY_BITS, log_inv_rate);

		// Calculate mask buffer dimensions using the shared function.
		let log_mul_constraints = checked_log_2(constraint_system.mul_constraints().len());
		let mask_degree = 2; // quadratic composition
		let mask_dims = mask_buffer_dimensions(log_mul_constraints, mask_degree, n_test_queries);
		let (m_n, m_d) = mask_dims;
		// log_batch_size accounts for the masks_mask (BaseFold mask for the mask commitment)
		let log_mask_dim = m_n + m_d;
		let log_mask_code_len = log_mask_dim + log_batch_size + log_inv_rate;

		// Create a single NTT with the max domain size for both witness and mask.
		let max_log_code_len = log_code_len.max(log_mask_code_len);
		let subspace = BinarySubspace::with_dim(max_log_code_len);
		let domain_context = GenericOnTheFly::generate_from_subspace(&subspace);
		let ntt = NeighborsLastSingleThread::new(domain_context);

		// Create oracle specs for the IOP channel
		let oracle_specs = vec![
			OracleSpec {
				log_msg_len: log_dim,
				is_zk: true,
			},
			OracleSpec {
				log_msg_len: log_mask_dim,
				is_zk: true,
			},
		];

		// Create the BaseFold compiler for IOP verification
		let basefold_compiler = BaseFoldVerifierCompiler::new(
			&ntt,
			merkle_scheme,
			oracle_specs,
			log_inv_rate,
			n_test_queries,
			&MinProofSizeStrategy,
		);

		Ok(Self {
			constraint_system,
			mask_dims,
			basefold_compiler,
		})
	}

	pub fn constraint_system(&self) -> &ConstraintSystemPadded {
		&self.constraint_system
	}

	/// Returns a reference to the BaseFold verifier compiler.
	pub fn iop_compiler(
		&self,
	) -> &BaseFoldVerifierCompiler<F, BinaryMerkleTreeScheme<F, MerkleHash, MerkleCompress>> {
		&self.basefold_compiler
	}

	/// Returns the mask buffer dimensions (m_n, m_d) for the ZK mulcheck mask polynomial.
	pub fn mask_dims(&self) -> (usize, usize) {
		self.mask_dims
	}

	/// Verifies a proof against the constraint system.
	///
	/// # Arguments
	///
	/// * `public` - The public inputs to the constraint system
	/// * `transcript` - The verifier transcript for Fiat-Shamir
	///
	/// # Preconditions
	///
	/// * The public input length must match the constraint system's public input size
	pub fn verify<Challenger_: Challenger>(
		&self,
		public: &[F],
		transcript: &mut VerifierTranscript<Challenger_>,
	) -> Result<(), Error> {
		// Create channel and delegate to verify_iop
		let channel = self.basefold_compiler.create_channel(transcript);
		self.verify_iop(public, channel)
	}

	/// Verifies a proof using an IOP channel.
	///
	/// This is an alternative interface for advanced users who want to provide their own
	/// channel implementation. Most users should use [`Self::verify`] instead.
	///
	/// # Arguments
	///
	/// * `public` - The public inputs to the constraint system
	/// * `channel` - The IOP verifier channel
	///
	/// # Returns
	///
	/// `Ok(())` if the proof is valid, `Err(_)` otherwise.
	pub fn verify_iop<Channel>(&self, public: &[F], mut channel: Channel) -> Result<(), Error>
	where
		Channel: IOPVerifierChannel<F>,
	{
		let _verify_guard =
			tracing::info_span!("Verify", operation = "verify", perfetto_category = "operation")
				.entered();

		let cs = self.constraint_system();

		// Check that the public input length is correct
		if public.len() != 1 << cs.log_public() {
			return Err(Error::IncorrectPublicInputLength {
				expected: 1 << self.constraint_system.log_public(),
				actual: public.len(),
			});
		}

		// Observe the public input (includes it in Fiat-Shamir).
		let public_elems = channel.observe_many(public);

		// Receive the trace oracle commitment.
		let trace_oracle = channel.recv_oracle()?;

		// Receive the mask oracle commitment.
		let mask_oracle = channel.recv_oracle()?;

		// Verify the multiplication constraints.
		let MulcheckOutput {
			a_eval,
			b_eval,
			c_eval,
			mask_eval,
			r_x,
		} = self.verify_mulcheck(&mut channel)?;

		// Sample the public input check challenge and evaluate the public input at the challenge
		// point.
		let r_public = channel.sample_many(cs.log_public() as usize);

		let public_eval = evaluate_inplace_scalars(public_elems, &r_public);

		// Compute wiring claim components
		let wiring_claim = wiring::compute_claim(
			&self.constraint_system,
			&r_public,
			&[a_eval, b_eval, c_eval],
			public_eval,
			&mut channel,
		);

		// Build the transparent closure for the wiring oracle relation
		let trace_transparent = wiring::eval_transparent(
			&self.constraint_system,
			&r_public,
			&r_x,
			wiring_claim.lambda,
			wiring_claim.batch_coeff,
		);

		// Build the transparent closure for the mask oracle relation
		let mask_transparent = self.mask_transparent(&r_x);

		// Finish the protocol with both oracle relations (checks are done inside finish)
		channel.finish(&[
			OracleLinearRelation {
				oracle: trace_oracle,
				transparent: trace_transparent,
				claim: wiring_claim.batched_sum,
			},
			OracleLinearRelation {
				oracle: mask_oracle,
				transparent: mask_transparent,
				claim: mask_eval,
			},
		])?;

		Ok(())
	}

	fn verify_mulcheck<C>(&self, channel: &mut C) -> Result<MulcheckOutput<C::Elem>, Error>
	where
		C: IPVerifierChannel<F>,
	{
		let log_mul_constraints = checked_log_2(self.constraint_system.mul_constraints().len());

		// Sample random evaluation point
		let r_mulcheck = channel.sample_many(log_mul_constraints);

		// Verify the zerocheck for the multiplication constraints.
		let mlecheck::VerifyZKOutput {
			eval,
			mask_eval,
			challenges: mut r_x,
		} = mlecheck::verify_zk(&r_mulcheck, 2, C::Elem::zero(), channel)?;

		// Reverse because sumcheck binds high-to-low variable indices.
		r_x.reverse();

		// Read the claimed evaluations
		let [a_eval, b_eval, c_eval] = channel.recv_array()?;

		channel.assert_zero(a_eval.clone() * b_eval.clone() - c_eval.clone() - eval)?;

		Ok(MulcheckOutput {
			a_eval,
			b_eval,
			c_eval,
			mask_eval,
			r_x,
		})
	}

	/// Returns a closure that evaluates the mask transparent polynomial at a given point.
	fn mask_transparent<'a, E: FieldOps + 'a>(
		&self,
		r_x: &[E],
	) -> binius_iop::channel::TransparentEvalFn<'a, E> {
		let (_m_n, m_d) = self.mask_dims;
		let n_vars = r_x.len();
		let mask_degree = 2; // quadratic composition
		let r_x = r_x.to_vec();

		Box::new(move |point: &[E]| {
			// point is in low-to-high order with batch_challenge at the end.
			// Extract the query point by excluding the batch challenge.
			let query_point = &point[..point.len() - 1];

			// Split into query_k (low-order bits) and query_j (high-order bits)
			let (query_k, query_j) = query_point.split_at(m_d);

			mlecheck::libra_eval(&r_x, query_j, query_k, n_vars, mask_degree)
		})
	}
}

#[derive(Debug, thiserror::Error)]
pub enum Error {
	#[error("FRI error: {0}")]
	FRI(#[from] fri::Error),
	#[error("PCS error: {0}")]
	PCS(#[from] pcs::Error),
	#[error("Sumcheck error: {0}")]
	Sumcheck(#[from] sumcheck::Error),
	#[error("BaseFold error: {0}")]
	BaseFold(#[from] basefold::Error),
	#[error("wiring error: {0}")]
	Wiring(#[from] wiring::Error),
	#[error("Transcript error: {0}")]
	Transcript(#[from] binius_transcript::Error),
	#[error("IOP channel error: {0}")]
	IOPChannel(#[from] binius_iop::channel::Error),
	#[error("IP channel error: {0}")]
	IPChannel(#[from] binius_ip::channel::Error),
	#[error("incorrect public inputs length: expected {expected}, got {actual}")]
	IncorrectPublicInputLength { expected: usize, actual: usize },
	#[error("incorrect reduction output of the multiplication check")]
	IncorrectMulCheckEvaluation,
}
